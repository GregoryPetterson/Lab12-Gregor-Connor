# Lab12-Gregor-Connor
A certain string-processing language allows a programmer to break a string into two pieces. Because this operation copies the string, it costs nn time units to break a string of nn characters into two pieces. Suppose a programmer wants to break a string into many pieces. The order in which the breaks occur can affect the total amount of time used. For example, suppose that the programmer wants to break a 2020-character string after characters 22, 88, and 1010 (numbering the characters in ascending order from the left-hand end, starting from 11). If she programs the breaks to occur in left-to-right order, then the first break costs 2020 time units, the second break costs 1818 time units (breaking the string from characters 33 to 2020 at character 88), and the third break costs 1212 time units, totaling 5050 time units. If she programs the breaks to occur in right-to-left order, however, then the first break costs 2020 time units, the second break costs 1010 time units, and the third break costs 88 time units, totaling 3838 time units. In yet another order, she could break first at 88 (costing 2020), then break the left piece at 22 (costing 88), and finally the right piece at 1010 (costing 1212), for a total cost of 4040.

Design an algorithm that, given the numbers of characters after which to break, determines a least-cost way to sequence those breaks. More formally, given a string SS with nn characters and an array L[1..m]L[1..m] containing the break points, com- pute the lowest cost for a sequence of breaks, along with a sequence of breaks that achieves this cost.

Written part: So we coded break-rod without memoization as an example to understand break-string better. The call to run that on this array of prices p[0, 1, 5, 8, 9, 12] is commented out in our main driver. We stepped through the call on a rod of length 4 on the white board, we forgot to take pictures, which took a while since it's exponential. 

We also made a matrice illustrating the bottom-up strategu, we forgot to take pictures. We had no idea how to code this solution. The memoization seemed more intuitive but in hindsight makes more sense after looking at the books bottom-up approach for break rod.

Our solution only prints out the breaks and cost for the best solution. We ran out of time and should've considered the books version of break-rod that gives a way of storing the subproblems in an array to print.

Analysis: We tied making each possible cut and took the one with cheapest cost. Since there are numberofBreaks to try and at most numberofBreaks^2 to index the subproblems with. The final runtime is O(numberofBreaks^3 lgn).